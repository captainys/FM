					BITS	32

					CALL	CAPTURE_EIP
CAPTURE_EIP:		POP		ESI			; ESI is CAPTURE_EIP
					ADD		ESI,(PATCH_CODE_BEGIN-CAPTURE_EIP)
					MOV		EDI,JUMP_TABLE
					MOV		ECX,(PATCH_CODE_END-PATCH_CODE_BEGIN)
					REP		MOVSB
					RET



; Table at 000C:001A7FFD
PATCH_CODE_BEGIN:
TABLE_BEGIN:
					DD		JUMP_TABLE+(CDDASTOP   -TABLE_BEGIN)	; 001A81A9 CMD #0  CDStop
					DD		JUMP_TABLE+(CDDAPLAY1_2-TABLE_BEGIN)	; 001A8025     #1  CDDAPlay1
					DD		JUMP_TABLE+(CDDAPLAY1_2-TABLE_BEGIN)	; 001A80E5     #2  CDDAPlay2
					DD		JUMP_TABLE+(CDDASTOP   -TABLE_BEGIN)	; 001A81A9     #3  CDStop
					DD		JUMP_TABLE+(CDDASTOP   -TABLE_BEGIN)	; 001A81A9     #4  CDStop
					DD		JUMP_TABLE+(CDDAPAUSE  -TABLE_BEGIN)	; 001A81B2     #5  CDDAPause
					DD		JUMP_TABLE+(CDDARESUME -TABLE_BEGIN)	; 001A81F4     #6  CDDAResume
					DD		JUMP_TABLE+(CDDANOP    -TABLE_BEGIN)	; 001A8238     #7  CDDASet?
					DD		JUMP_TABLE+(CDDAPLAY8  -TABLE_BEGIN)	; 001A8096     #8  CDDAPlay8
					DD		JUMP_TABLE+(CDDAPLAY9  -TABLE_BEGIN)	; 001A8158     #9  CDDAPlay9


CDDAPAUSE:
					MOV		AH,55h
					JMP		SHORT SHOOT_SIMPLE_INT93

CDDASTOP:
					MOV		AH,52h
					JMP		SHORT SHOOT_SIMPLE_INT93

CDDARESUME:
					MOV		AH,56h
					; JMP 	SHORT SHOOT_SIMPLE_INT93

SHOOT_SIMPLE_INT93:
					MOV		AL,0C0H
					XOR		ECX,ECX
					INT		93H
CDDANOP:
					RET



CDDAPLAY8:
					MOV		AH,1
					JMP		SHORT CDDAPLAY8_9
CDDAPLAY9:
					MOV		AH,02
CDDAPLAY8_9:
					CMP		AL,[PLAYING_TRACK]	; To prevent flicker.
					JE		CDDANOP
					MOV		[PLAYING_TRACK],AL

					PUSH	EAX
					CALL	CDDAPLAY
					AND		AH,AH
					POP		EAX

					JNE		CDDAPLAY8_9_END	; If error, remember what failed so that it will try again.
							                ; The original code writes the 0x02?? if CDC returns status 01 xx xx xx (Command Acceptance Error)
											; But, if I do it, it stops playing???

					XOR		EAX,EAX

CDDAPLAY8_9_END:
					MOV		[PLAYING_TRACK_PLUS_200H],AX
					RET



CDDAPLAY1_2:
					MOV		[PLAYING_TRACK],AL
					; JMP	CDDAPLAY

CDDAPLAY:
					SUB		ESP,14H		; Make a register table for INT 21H AX=2511H

					MOVZX	ECX,AL		; By this I clear High-24bits of ECX.
					LEA		EAX,[ECX+ECX*2]
					LEA		ESI,[EAX*2+TOC_TABLE];

					MOV		BX,1
					MOV		AX,25C0h	; DOS Alloc -> AX=segment
					INT		21H			; It shouldn't change ECX.  High-24bits of ECX is stil zero.
					JC		CDDAPLAY_EXIT

					; Set Up INT 93H via INT 21H AX=2511H before forgetting the real-mode segment.
					MOV		WORD [ESP],93H			; INT 93H
					MOV		[ESP+2],AX				; DS in the real mode
					MOV		WORD [ESP+0AH],50C0H	; 50H CDDA Play

					MOV		CL,060h		; DOS Extender GDT 0060H DOS memory space.  High-24bits of ECX is still clear.
					MOV		ES,CX		; ES is backed up above, so don't worry about destroying it.
					MOVZX	EDI,AX
					SHL		EDI,4

					SHR		ECX,4		; DOS memory-space selector happens to be 0060H.  I can get 6 by right-shifting by 4.
BCD2BIN_LOOP:		LODSB

					; BCD2BIN >>>>
					MOV		BL,AL

					SHR		AL,4
					MOV		AH,10
					MUL		AH		; Make AL is 10*high_digit

					AND		BL,0Fh
					ADD		AL,BL
					; BCD2BIN <<<<

					STOSB
					LOOP	BCD2BIN_LOOP

					MOV		AX,52C0h
					; XOR		CX,CX	; Just got out of LOOP BCD2BIN_LOOP, therefore ECX is already zero.
					INT		93H			; CDDA Stop

					XOR		EDI,EDI
					MOV		EDX,ESP		; DS:EDX is parameter block, already set up above.
					MOV		CX,1
					MOV		AX,2511H	; Call Real Mode INT
					INT		21H

					MOV		CX,[ESP+2]				; Recover real-mode segment.  Fetch it before PUSH EAX.
					PUSH	EAX			; Save return value.
					MOV		AX,25C1h	; DOS Free <- CX=segment
					INT		21H
					POP		EAX

CDDAPLAY_EXIT:
					ADD		ESP,14H
					RET
PATCH_CODE_END:
